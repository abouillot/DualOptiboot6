
optiboot_miniwireless.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004fa  00007800  00007800  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .version      00000002  00007ffe  00007ffe  0000056e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .debug_aranges 00000028  00000000  00000000  00000570  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000000cd  00000000  00000000  00000598  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000082b  00000000  00000000  00000665  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000027e  00000000  00000000  00000e90  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   0000091b  00000000  00000000  0000110e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000000d0  00000000  00000000  00001a2c  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000022f  00000000  00000000  00001afc  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    0000054f  00000000  00000000  00001d2b  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000158  00000000  00000000  0000227a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00007800 <main>:
}
/******************* END SPI FLASH Code ****************************/


/* main program starts here */
int main(void) {
    7800:	11 24       	eor	r1, r1
   * modified Adaboot no-wait mod.
   * Pass the reset reason to app.  Also, it appears that an Uno poweron
   * can leave multiple reset flags set; we only want the bootloader to
   * run on an 'external reset only' status
   */
  ch = MCUSR;
    7802:	14 b7       	in	r17, 0x34	; 52
  MCUSR = 0;
    7804:	14 be       	out	0x34, r1	; 52
//ORIG.OPTIBOOT  if (ch & (_BV(WDRF) | _BV(BORF) | _BV(PORF)))
//ORIG.OPTIBOOT      appStart(ch);

  if (!(ch & _BV(EXTRF))) //if not external reset
    7806:	11 fd       	sbrc	r17, 1
    7808:	07 c0       	rjmp	.+14     	; 0x7818 <main+0x18>
  {
    if (ch & _BV(WDRF)) //if reset by watchdog
    780a:	13 ff       	sbrs	r17, 3
    780c:	01 c0       	rjmp	.+2      	; 0x7810 <main+0x10>
      CheckFlashImage();
    780e:	67 d1       	rcall	.+718    	; 0x7ade <CheckFlashImage>
#ifdef DEBUG_ON
    putch('A');
    7810:	81 e4       	ldi	r24, 0x41	; 65
    7812:	3b d1       	rcall	.+630    	; 0x7a8a <putch>
#endif
    appStart(ch);
    7814:	81 2f       	mov	r24, r17
    7816:	6b d2       	rcall	.+1238   	; 0x7cee <appStart>
  }

#if LED_START_FLASHES > 0
  // Set up Timer 1 for timeout counter
  TCCR1B = _BV(CS12) | _BV(CS10); // div 1024
    7818:	85 e0       	ldi	r24, 0x05	; 5
    781a:	80 93 81 00 	sts	0x0081, r24
  UCSRA = _BV(U2X); //Double speed mode USART
  UCSRB = _BV(RXEN) | _BV(TXEN);  // enable Rx & Tx
  UCSRC = _BV(URSEL) | _BV(UCSZ1) | _BV(UCSZ0);  // config USART; 8N1
  UBRRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
#else
  UART_SRA = _BV(U2X0); //Double speed mode USART0
    781e:	82 e0       	ldi	r24, 0x02	; 2
    7820:	80 93 c0 00 	sts	0x00C0, r24
  UART_SRB = _BV(RXEN0) | _BV(TXEN0);
    7824:	88 e1       	ldi	r24, 0x18	; 24
    7826:	80 93 c1 00 	sts	0x00C1, r24
  UART_SRC = _BV(UCSZ00) | _BV(UCSZ01);
    782a:	86 e0       	ldi	r24, 0x06	; 6
    782c:	80 93 c2 00 	sts	0x00C2, r24
  UART_SRL = (uint8_t)( (F_CPU + BAUD_RATE * 4L) / (BAUD_RATE * 8L) - 1 );
    7830:	80 e1       	ldi	r24, 0x10	; 16
    7832:	80 93 c4 00 	sts	0x00C4, r24
#endif
#endif

  // Set up watchdog to trigger after 500ms
  watchdogConfig(WATCHDOG_1S);
    7836:	8e e0       	ldi	r24, 0x0E	; 14
    7838:	3c d1       	rcall	.+632    	; 0x7ab2 <watchdogConfig>

#if (LED_START_FLASHES > 0) || defined(LED_DATA_FLASH)
  /* Set LED pin as output */
  LED_DDR |= _BV(LED);
    783a:	21 9a       	sbi	0x04, 1	; 4
    783c:	86 e0       	ldi	r24, 0x06	; 6
}

#if LED_START_FLASHES > 0
void flash_led(uint8_t count) {
  do {
    TCNT1 = -(F_CPU/(1024*16));
    783e:	20 e3       	ldi	r18, 0x30	; 48
    7840:	3c ef       	ldi	r19, 0xFC	; 252
    TIFR1 = _BV(TOV1);
    7842:	91 e0       	ldi	r25, 0x01	; 1
}

#if LED_START_FLASHES > 0
void flash_led(uint8_t count) {
  do {
    TCNT1 = -(F_CPU/(1024*16));
    7844:	30 93 85 00 	sts	0x0085, r19
    7848:	20 93 84 00 	sts	0x0084, r18
    TIFR1 = _BV(TOV1);
    784c:	96 bb       	out	0x16, r25	; 22
    while(!(TIFR1 & _BV(TOV1)));
    784e:	b0 9b       	sbis	0x16, 0	; 22
    7850:	fe cf       	rjmp	.-4      	; 0x784e <main+0x4e>
#if defined(__AVR_ATmega8__)  || defined (__AVR_ATmega32__)
    LED_PORT ^= _BV(LED);
#else
    LED_PIN |= _BV(LED);
    7852:	19 9a       	sbi	0x03, 1	; 3
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
    7854:	a8 95       	wdr
    LED_PORT ^= _BV(LED);
#else
    LED_PIN |= _BV(LED);
#endif
    watchdogReset();
  } while (--count);
    7856:	81 50       	subi	r24, 0x01	; 1
    7858:	a9 f7       	brne	.-22     	; 0x7844 <main+0x44>
    785a:	ee 24       	eor	r14, r14
    785c:	ff 24       	eor	r15, r15
	     * Start the page erase and wait for it to finish.  There
	     * used to be code to do this while receiving the data over
	     * the serial link, but the performance improvement was slight,
	     * and we needed the space back.
	     */
	    __boot_page_erase_short((uint16_t)(void*)address);
    785e:	83 e0       	ldi	r24, 0x03	; 3
    7860:	b8 2e       	mov	r11, r24
	     */
	    do {
		uint16_t a;
		a = *bufPtr++;
		a |= (*bufPtr++) << 8;
		__boot_page_fill_short((uint16_t)(void*)addrPtr,a);
    7862:	aa 24       	eor	r10, r10
    7864:	a3 94       	inc	r10
	    } while (len -= 2);

	    /*
	     * Actually Write the buffer to flash (and wait for it to finish.)
	     */
	    __boot_page_write_short((uint16_t)(void*)address);
    7866:	05 e0       	ldi	r16, 0x05	; 5
    7868:	d0 2e       	mov	r13, r16
	    boot_spm_busy_wait();
#if defined(RWWSRE)
	    // Reenable read access to flash
	    boot_rww_enable();
    786a:	11 e1       	ldi	r17, 0x11	; 17
    786c:	c1 2e       	mov	r12, r17
#endif

  /* Forever loop: exits by causing WDT reset */
  for (;;) {
    /* get character from UART */
    ch = getch();
    786e:	15 d1       	rcall	.+554    	; 0x7a9a <getch>

    if(ch == STK_GET_PARAMETER) {
    7870:	81 34       	cpi	r24, 0x41	; 65
    7872:	71 f4       	brne	.+28     	; 0x7890 <main+0x90>
      unsigned char which = getch();
    7874:	12 d1       	rcall	.+548    	; 0x7a9a <getch>
    7876:	18 2f       	mov	r17, r24
      verifySpace();
    7878:	22 d1       	rcall	.+580    	; 0x7abe <verifySpace>
      /*
       * Send optiboot version as "SW version"
       * Note that the references to memory are optimized away.
       */
      if (which == 0x82) {
    787a:	12 38       	cpi	r17, 0x82	; 130
    787c:	11 f4       	brne	.+4      	; 0x7882 <main+0x82>
	  putch(optiboot_version & 0xFF);
    787e:	82 e0       	ldi	r24, 0x02	; 2
    7880:	05 c0       	rjmp	.+10     	; 0x788c <main+0x8c>
      } else if (which == 0x81) {
    7882:	11 38       	cpi	r17, 0x81	; 129
    7884:	11 f4       	brne	.+4      	; 0x788a <main+0x8a>
	  putch(optiboot_version >> 8);
    7886:	8a e1       	ldi	r24, 0x1A	; 26
    7888:	01 c0       	rjmp	.+2      	; 0x788c <main+0x8c>
      } else {
	/*
	 * GET PARAMETER returns a generic 0x03 reply for
         * other parameters - enough to keep Avrdude happy
	 */
	putch(0x03);
    788a:	83 e0       	ldi	r24, 0x03	; 3
    788c:	fe d0       	rcall	.+508    	; 0x7a8a <putch>
    788e:	9c c0       	rjmp	.+312    	; 0x79c8 <main+0x1c8>
      }
    }
    else if(ch == STK_SET_DEVICE) {
    7890:	82 34       	cpi	r24, 0x42	; 66
    7892:	11 f4       	brne	.+4      	; 0x7898 <main+0x98>
      // SET DEVICE is ignored
      getNch(20);
    7894:	84 e1       	ldi	r24, 0x14	; 20
    7896:	03 c0       	rjmp	.+6      	; 0x789e <main+0x9e>
    }
    else if(ch == STK_SET_DEVICE_EXT) {
    7898:	85 34       	cpi	r24, 0x45	; 69
    789a:	19 f4       	brne	.+6      	; 0x78a2 <main+0xa2>
      // SET DEVICE EXT is ignored
      getNch(5);
    789c:	85 e0       	ldi	r24, 0x05	; 5
    789e:	17 d1       	rcall	.+558    	; 0x7ace <getNch>
    78a0:	93 c0       	rjmp	.+294    	; 0x79c8 <main+0x1c8>
    }
    else if(ch == STK_LOAD_ADDRESS) {
    78a2:	85 35       	cpi	r24, 0x55	; 85
    78a4:	79 f4       	brne	.+30     	; 0x78c4 <main+0xc4>
      // LOAD ADDRESS
      uint16_t newAddress;
      newAddress = getch();
    78a6:	f9 d0       	rcall	.+498    	; 0x7a9a <getch>
      newAddress = (newAddress & 0xff) | (getch() << 8);
    78a8:	e8 2e       	mov	r14, r24
    78aa:	ff 24       	eor	r15, r15
    78ac:	f6 d0       	rcall	.+492    	; 0x7a9a <getch>
    78ae:	08 2f       	mov	r16, r24
    78b0:	10 e0       	ldi	r17, 0x00	; 0
    78b2:	10 2f       	mov	r17, r16
    78b4:	00 27       	eor	r16, r16
    78b6:	0e 29       	or	r16, r14
    78b8:	1f 29       	or	r17, r15
#ifdef RAMPZ
      // Transfer top bit to RAMPZ
      RAMPZ = (newAddress & 0x8000) ? 1 : 0;
#endif
      newAddress += newAddress; // Convert from word address to byte address
    78ba:	00 0f       	add	r16, r16
    78bc:	11 1f       	adc	r17, r17
      address = newAddress;
      verifySpace();
    78be:	ff d0       	rcall	.+510    	; 0x7abe <verifySpace>
    78c0:	78 01       	movw	r14, r16
    78c2:	82 c0       	rjmp	.+260    	; 0x79c8 <main+0x1c8>
    }
    else if(ch == STK_UNIVERSAL) {
    78c4:	86 35       	cpi	r24, 0x56	; 86
    78c6:	21 f4       	brne	.+8      	; 0x78d0 <main+0xd0>
      // UNIVERSAL command is ignored
      getNch(4);
    78c8:	84 e0       	ldi	r24, 0x04	; 4
    78ca:	01 d1       	rcall	.+514    	; 0x7ace <getNch>
      putch(0x00);
    78cc:	80 e0       	ldi	r24, 0x00	; 0
    78ce:	de cf       	rjmp	.-68     	; 0x788c <main+0x8c>
    }
    /* Write memory, length is big endian and is in bytes */
    else if(ch == STK_PROG_PAGE) {
    78d0:	84 36       	cpi	r24, 0x64	; 100
    78d2:	09 f0       	breq	.+2      	; 0x78d6 <main+0xd6>
    78d4:	4b c0       	rjmp	.+150    	; 0x796c <main+0x16c>
      // PROGRAM PAGE - we support flash programming only, not EEPROM
      uint8_t desttype;
      uint8_t *bufPtr;
      pagelen_t savelength;

      GETLENGTH(length);
    78d6:	e1 d0       	rcall	.+450    	; 0x7a9a <getch>
    78d8:	e0 d0       	rcall	.+448    	; 0x7a9a <getch>
    78da:	08 2f       	mov	r16, r24
      savelength = length;
      desttype = getch();
    78dc:	de d0       	rcall	.+444    	; 0x7a9a <getch>
    78de:	18 2f       	mov	r17, r24
    78e0:	c0 e0       	ldi	r28, 0x00	; 0
    78e2:	d1 e0       	ldi	r29, 0x01	; 1

      // read a page worth of contents
      bufPtr = buff;
      do *bufPtr++ = getch();
    78e4:	da d0       	rcall	.+436    	; 0x7a9a <getch>
    78e6:	89 93       	st	Y+, r24
      while (--length);
    78e8:	0c 17       	cp	r16, r28
    78ea:	e1 f7       	brne	.-8      	; 0x78e4 <main+0xe4>

      // Read command terminator, start reply
      verifySpace();
    78ec:	e8 d0       	rcall	.+464    	; 0x7abe <verifySpace>
 * void writebuffer(memtype, buffer, address, length)
 */
static inline void writebuffer(int8_t memtype, uint8_t *mybuff,
			       uint16_t address, pagelen_t len)
{
    switch (memtype) {
    78ee:	15 34       	cpi	r17, 0x45	; 69
    78f0:	b9 f4       	brne	.+46     	; 0x7920 <main+0x120>
    78f2:	97 01       	movw	r18, r14
    78f4:	e0 e0       	ldi	r30, 0x00	; 0
    78f6:	f1 e0       	ldi	r31, 0x01	; 1
    78f8:	10 c0       	rjmp	.+32     	; 0x791a <main+0x11a>
    case 'E': // EEPROM
#if defined(SUPPORT_EEPROM) || defined(BIGBOOT)
        while(len--) {
	    eeprom_write_byte((uint8_t *)(address++), *mybuff++);
    78fa:	40 81       	ld	r20, Z
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    78fc:	f9 99       	sbic	0x1f, 1	; 31
    78fe:	fe cf       	rjmp	.-4      	; 0x78fc <main+0xfc>
    7900:	c9 01       	movw	r24, r18
    7902:	01 96       	adiw	r24, 0x01	; 1
    7904:	31 96       	adiw	r30, 0x01	; 1

#if	defined(EEPM0) && defined(EEPM1)
    EECR = 0;		/* Set programming mode: erase and write.	*/
    7906:	1f ba       	out	0x1f, r1	; 31
#endif

#if	E2END <= 0xFF
    EEARL = (unsigned)__p;
#else
    EEAR = (unsigned)__p;
    7908:	32 bd       	out	0x22, r19	; 34
    790a:	21 bd       	out	0x21, r18	; 33
#endif
    EEDR = __value;
    790c:	40 bd       	out	0x20, r20	; 32

    __asm__ __volatile__ (
    790e:	0f b6       	in	r0, 0x3f	; 63
    7910:	f8 94       	cli
    7912:	fa 9a       	sbi	0x1f, 2	; 31
    7914:	f9 9a       	sbi	0x1f, 1	; 31
    7916:	0f be       	out	0x3f, r0	; 63
    7918:	9c 01       	movw	r18, r24
			       uint16_t address, pagelen_t len)
{
    switch (memtype) {
    case 'E': // EEPROM
#if defined(SUPPORT_EEPROM) || defined(BIGBOOT)
        while(len--) {
    791a:	0e 17       	cp	r16, r30
    791c:	71 f7       	brne	.-36     	; 0x78fa <main+0xfa>
    791e:	54 c0       	rjmp	.+168    	; 0x79c8 <main+0x1c8>
	     * Start the page erase and wait for it to finish.  There
	     * used to be code to do this while receiving the data over
	     * the serial link, but the performance improvement was slight,
	     * and we needed the space back.
	     */
	    __boot_page_erase_short((uint16_t)(void*)address);
    7920:	f7 01       	movw	r30, r14
    7922:	b7 be       	out	0x37, r11	; 55
    7924:	e8 95       	spm
	    boot_spm_busy_wait();
    7926:	07 b6       	in	r0, 0x37	; 55
    7928:	00 fc       	sbrc	r0, 0
    792a:	fd cf       	rjmp	.-6      	; 0x7926 <main+0x126>
    792c:	a7 01       	movw	r20, r14
    792e:	a0 e0       	ldi	r26, 0x00	; 0
    7930:	b1 e0       	ldi	r27, 0x01	; 1
	    /*
	     * Copy data from the buffer into the flash write buffer.
	     */
	    do {
		uint16_t a;
		a = *bufPtr++;
    7932:	2c 91       	ld	r18, X
    7934:	30 e0       	ldi	r19, 0x00	; 0
		a |= (*bufPtr++) << 8;
    7936:	11 96       	adiw	r26, 0x01	; 1
    7938:	8c 91       	ld	r24, X
    793a:	11 97       	sbiw	r26, 0x01	; 1
    793c:	90 e0       	ldi	r25, 0x00	; 0
    793e:	98 2f       	mov	r25, r24
    7940:	88 27       	eor	r24, r24
    7942:	82 2b       	or	r24, r18
    7944:	93 2b       	or	r25, r19
}
/******************* END SPI FLASH Code ****************************/


/* main program starts here */
int main(void) {
    7946:	12 96       	adiw	r26, 0x02	; 2
	     */
	    do {
		uint16_t a;
		a = *bufPtr++;
		a |= (*bufPtr++) << 8;
		__boot_page_fill_short((uint16_t)(void*)addrPtr,a);
    7948:	fa 01       	movw	r30, r20
    794a:	0c 01       	movw	r0, r24
    794c:	a7 be       	out	0x37, r10	; 55
    794e:	e8 95       	spm
    7950:	11 24       	eor	r1, r1
		addrPtr += 2;
    7952:	4e 5f       	subi	r20, 0xFE	; 254
    7954:	5f 4f       	sbci	r21, 0xFF	; 255
	    } while (len -= 2);
    7956:	0a 17       	cp	r16, r26
    7958:	61 f7       	brne	.-40     	; 0x7932 <main+0x132>

	    /*
	     * Actually Write the buffer to flash (and wait for it to finish.)
	     */
	    __boot_page_write_short((uint16_t)(void*)address);
    795a:	f7 01       	movw	r30, r14
    795c:	d7 be       	out	0x37, r13	; 55
    795e:	e8 95       	spm
	    boot_spm_busy_wait();
    7960:	07 b6       	in	r0, 0x37	; 55
    7962:	00 fc       	sbrc	r0, 0
    7964:	fd cf       	rjmp	.-6      	; 0x7960 <main+0x160>
#if defined(RWWSRE)
	    // Reenable read access to flash
	    boot_rww_enable();
    7966:	c7 be       	out	0x37, r12	; 55
    7968:	e8 95       	spm
    796a:	2e c0       	rjmp	.+92     	; 0x79c8 <main+0x1c8>
      writebuffer(desttype, buff, address, savelength);


    }
    /* Read memory block mode, length is big endian.  */
    else if(ch == STK_READ_PAGE) {
    796c:	84 37       	cpi	r24, 0x74	; 116
    796e:	f1 f4       	brne	.+60     	; 0x79ac <main+0x1ac>
      uint8_t desttype;
      GETLENGTH(length);
    7970:	94 d0       	rcall	.+296    	; 0x7a9a <getch>
    7972:	93 d0       	rcall	.+294    	; 0x7a9a <getch>
    7974:	08 2f       	mov	r16, r24

      desttype = getch();
    7976:	91 d0       	rcall	.+290    	; 0x7a9a <getch>
    7978:	18 2f       	mov	r17, r24

      verifySpace();
    797a:	a1 d0       	rcall	.+322    	; 0x7abe <verifySpace>

static inline void read_mem(uint8_t memtype, uint16_t address, pagelen_t length)
{
    uint8_t ch;

    switch (memtype) {
    797c:	15 34       	cpi	r17, 0x45	; 69
    797e:	71 f4       	brne	.+28     	; 0x799c <main+0x19c>
    7980:	c7 01       	movw	r24, r14

#if defined(SUPPORT_EEPROM) || defined(BIGBOOT)
    case 'E': // EEPROM
	do {
	    putch(eeprom_read_byte((uint8_t *)(address++)));
    7982:	ec 01       	movw	r28, r24
    7984:	21 96       	adiw	r28, 0x01	; 1
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    7986:	f9 99       	sbic	0x1f, 1	; 31
    7988:	fe cf       	rjmp	.-4      	; 0x7986 <main+0x186>
#if E2END <= 0xFF
    EEARL = (uint8_t)(uint16_t)__p;
#else
    EEAR = (uint16_t)__p;
    798a:	92 bd       	out	0x22, r25	; 34
    798c:	81 bd       	out	0x21, r24	; 33
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    798e:	f8 9a       	sbi	0x1f, 0	; 31
    7990:	80 b5       	in	r24, 0x20	; 32
    7992:	7b d0       	rcall	.+246    	; 0x7a8a <putch>
	} while (--length);
    7994:	01 50       	subi	r16, 0x01	; 1
    7996:	c1 f0       	breq	.+48     	; 0x79c8 <main+0x1c8>
    7998:	ce 01       	movw	r24, r28
    799a:	f3 cf       	rjmp	.-26     	; 0x7982 <main+0x182>
    799c:	e7 01       	movw	r28, r14
	    __asm__ ("elpm %0,Z+\n" : "=r" (ch), "=z" (address): "1" (address));
#else
	    // read a Flash byte and increment the address
	    __asm__ ("lpm %0,Z+\n" : "=r" (ch), "=z" (address): "1" (address));
#endif
	    putch(ch);
    799e:	fe 01       	movw	r30, r28
    79a0:	85 91       	lpm	r24, Z+
    79a2:	ef 01       	movw	r28, r30
    79a4:	72 d0       	rcall	.+228    	; 0x7a8a <putch>
	} while (--length);
    79a6:	01 50       	subi	r16, 0x01	; 1
    79a8:	d1 f7       	brne	.-12     	; 0x799e <main+0x19e>
    79aa:	0e c0       	rjmp	.+28     	; 0x79c8 <main+0x1c8>
	  
      read_mem(desttype, address, length);
    }

    /* Get device signature bytes  */
    else if(ch == STK_READ_SIGN) {
    79ac:	85 37       	cpi	r24, 0x75	; 117
    79ae:	39 f4       	brne	.+14     	; 0x79be <main+0x1be>
      // READ SIGN - return what Avrdude wants to hear
      verifySpace();
    79b0:	86 d0       	rcall	.+268    	; 0x7abe <verifySpace>
      putch(SIGNATURE_0);
    79b2:	8e e1       	ldi	r24, 0x1E	; 30
    79b4:	6a d0       	rcall	.+212    	; 0x7a8a <putch>
      putch(SIGNATURE_1);
    79b6:	85 e9       	ldi	r24, 0x95	; 149
    79b8:	68 d0       	rcall	.+208    	; 0x7a8a <putch>
      putch(SIGNATURE_2);
    79ba:	8f e0       	ldi	r24, 0x0F	; 15
    79bc:	67 cf       	rjmp	.-306    	; 0x788c <main+0x8c>
    }
    else if (ch == STK_LEAVE_PROGMODE) { /* 'Q' */
    79be:	81 35       	cpi	r24, 0x51	; 81
    79c0:	11 f4       	brne	.+4      	; 0x79c6 <main+0x1c6>
      // Adaboot no-wait mod
      watchdogConfig(WATCHDOG_16MS);
    79c2:	88 e0       	ldi	r24, 0x08	; 8
    79c4:	76 d0       	rcall	.+236    	; 0x7ab2 <watchdogConfig>
      verifySpace();
    }
    else {
      // This covers the response to commands like STK_ENTER_PROGMODE
      verifySpace();
    79c6:	7b d0       	rcall	.+246    	; 0x7abe <verifySpace>
    }
    putch(STK_OK);
    79c8:	80 e1       	ldi	r24, 0x10	; 16
    79ca:	5f d0       	rcall	.+190    	; 0x7a8a <putch>
    79cc:	50 cf       	rjmp	.-352    	; 0x786e <main+0x6e>

000079ce <SPI_transfer>:

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    79ce:	8e bd       	out	0x2e, r24	; 46
  while (!(SPSR & _BV(SPIF)));
    79d0:	0d b4       	in	r0, 0x2d	; 45
    79d2:	07 fe       	sbrs	r0, 7
    79d4:	fd cf       	rjmp	.-6      	; 0x79d0 <SPI_transfer+0x2>
  return SPDR;
    79d6:	8e b5       	in	r24, 0x2e	; 46
}
    79d8:	08 95       	ret

000079da <FLASH_busy>:

uint8_t FLASH_busy()
{
  FLASH_SELECT;
    79da:	5d 98       	cbi	0x0b, 5	; 11

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    79dc:	85 e0       	ldi	r24, 0x05	; 5
    79de:	8e bd       	out	0x2e, r24	; 46
  while (!(SPSR & _BV(SPIF)));
    79e0:	0d b4       	in	r0, 0x2d	; 45
    79e2:	07 fe       	sbrs	r0, 7
    79e4:	fd cf       	rjmp	.-6      	; 0x79e0 <FLASH_busy+0x6>
  return SPDR;
    79e6:	8e b5       	in	r24, 0x2e	; 46

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    79e8:	1e bc       	out	0x2e, r1	; 46
  while (!(SPSR & _BV(SPIF)));
    79ea:	0d b4       	in	r0, 0x2d	; 45
    79ec:	07 fe       	sbrs	r0, 7
    79ee:	fd cf       	rjmp	.-6      	; 0x79ea <FLASH_busy+0x10>
  return SPDR;
    79f0:	8e b5       	in	r24, 0x2e	; 46
uint8_t FLASH_busy()
{
  FLASH_SELECT;
  SPI_transfer(SPIFLASH_STATUSREAD);
  uint8_t status = SPI_transfer(0);
  FLASH_UNSELECT;
    79f2:	5d 9a       	sbi	0x0b, 5	; 11
  return status & 1;
}
    79f4:	81 70       	andi	r24, 0x01	; 1
    79f6:	08 95       	ret

000079f8 <FLASH_command>:

void FLASH_command(uint8_t cmd, uint8_t isWrite){
    79f8:	1f 93       	push	r17
    79fa:	18 2f       	mov	r17, r24
  if (isWrite)
    79fc:	66 23       	and	r22, r22
    79fe:	21 f0       	breq	.+8      	; 0x7a08 <FLASH_command+0x10>
  {
    FLASH_command(SPIFLASH_WRITEENABLE, 0); // Write Enable
    7a00:	86 e0       	ldi	r24, 0x06	; 6
    7a02:	60 e0       	ldi	r22, 0x00	; 0
    7a04:	f9 df       	rcall	.-14     	; 0x79f8 <FLASH_command>
    FLASH_UNSELECT;
    7a06:	5d 9a       	sbi	0x0b, 5	; 11

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7a08:	95 e0       	ldi	r25, 0x05	; 5
  return SPDR;
}

uint8_t FLASH_busy()
{
  FLASH_SELECT;
    7a0a:	5d 98       	cbi	0x0b, 5	; 11

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7a0c:	9e bd       	out	0x2e, r25	; 46
  while (!(SPSR & _BV(SPIF)));
    7a0e:	0d b4       	in	r0, 0x2d	; 45
    7a10:	07 fe       	sbrs	r0, 7
    7a12:	fd cf       	rjmp	.-6      	; 0x7a0e <FLASH_command+0x16>
  return SPDR;
    7a14:	8e b5       	in	r24, 0x2e	; 46

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7a16:	1e bc       	out	0x2e, r1	; 46
  while (!(SPSR & _BV(SPIF)));
    7a18:	0d b4       	in	r0, 0x2d	; 45
    7a1a:	07 fe       	sbrs	r0, 7
    7a1c:	fd cf       	rjmp	.-6      	; 0x7a18 <FLASH_command+0x20>
  return SPDR;
    7a1e:	8e b5       	in	r24, 0x2e	; 46
uint8_t FLASH_busy()
{
  FLASH_SELECT;
  SPI_transfer(SPIFLASH_STATUSREAD);
  uint8_t status = SPI_transfer(0);
  FLASH_UNSELECT;
    7a20:	5d 9a       	sbi	0x0b, 5	; 11
  if (isWrite)
  {
    FLASH_command(SPIFLASH_WRITEENABLE, 0); // Write Enable
    FLASH_UNSELECT;
  }
  while(FLASH_busy()); //wait for chip to become available
    7a22:	80 fd       	sbrc	r24, 0
    7a24:	f2 cf       	rjmp	.-28     	; 0x7a0a <FLASH_command+0x12>
  FLASH_SELECT;
    7a26:	5d 98       	cbi	0x0b, 5	; 11

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7a28:	1e bd       	out	0x2e, r17	; 46
  while (!(SPSR & _BV(SPIF)));
    7a2a:	0d b4       	in	r0, 0x2d	; 45
    7a2c:	07 fe       	sbrs	r0, 7
    7a2e:	fd cf       	rjmp	.-6      	; 0x7a2a <FLASH_command+0x32>
  return SPDR;
    7a30:	8e b5       	in	r24, 0x2e	; 46
    FLASH_UNSELECT;
  }
  while(FLASH_busy()); //wait for chip to become available
  FLASH_SELECT;
  SPI_transfer(cmd);
}
    7a32:	1f 91       	pop	r17
    7a34:	08 95       	ret

00007a36 <FLASH_readByte>:

uint8_t FLASH_readByte(uint32_t addr) {
    7a36:	ef 92       	push	r14
    7a38:	ff 92       	push	r15
    7a3a:	0f 93       	push	r16
    7a3c:	1f 93       	push	r17
    7a3e:	7b 01       	movw	r14, r22
    7a40:	8c 01       	movw	r16, r24
  FLASH_command(SPIFLASH_ARRAYREADLOWFREQ, 0);
    7a42:	83 e0       	ldi	r24, 0x03	; 3
    7a44:	60 e0       	ldi	r22, 0x00	; 0
    7a46:	d8 df       	rcall	.-80     	; 0x79f8 <FLASH_command>
  SPI_transfer(addr >> 16);
    7a48:	c8 01       	movw	r24, r16
    7a4a:	aa 27       	eor	r26, r26
    7a4c:	bb 27       	eor	r27, r27

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7a4e:	8e bd       	out	0x2e, r24	; 46
  while (!(SPSR & _BV(SPIF)));
    7a50:	0d b4       	in	r0, 0x2d	; 45
    7a52:	07 fe       	sbrs	r0, 7
    7a54:	fd cf       	rjmp	.-6      	; 0x7a50 <FLASH_readByte+0x1a>
  return SPDR;
    7a56:	8e b5       	in	r24, 0x2e	; 46
}

uint8_t FLASH_readByte(uint32_t addr) {
  FLASH_command(SPIFLASH_ARRAYREADLOWFREQ, 0);
  SPI_transfer(addr >> 16);
  SPI_transfer(addr >> 8);
    7a58:	bb 27       	eor	r27, r27
    7a5a:	a1 2f       	mov	r26, r17
    7a5c:	90 2f       	mov	r25, r16
    7a5e:	8f 2d       	mov	r24, r15

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7a60:	8e bd       	out	0x2e, r24	; 46
  while (!(SPSR & _BV(SPIF)));
    7a62:	0d b4       	in	r0, 0x2d	; 45
    7a64:	07 fe       	sbrs	r0, 7
    7a66:	fd cf       	rjmp	.-6      	; 0x7a62 <FLASH_readByte+0x2c>
  return SPDR;
    7a68:	8e b5       	in	r24, 0x2e	; 46

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7a6a:	ee bc       	out	0x2e, r14	; 46
  while (!(SPSR & _BV(SPIF)));
    7a6c:	0d b4       	in	r0, 0x2d	; 45
    7a6e:	07 fe       	sbrs	r0, 7
    7a70:	fd cf       	rjmp	.-6      	; 0x7a6c <FLASH_readByte+0x36>
  return SPDR;
    7a72:	8e b5       	in	r24, 0x2e	; 46

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7a74:	1e bc       	out	0x2e, r1	; 46
  while (!(SPSR & _BV(SPIF)));
    7a76:	0d b4       	in	r0, 0x2d	; 45
    7a78:	07 fe       	sbrs	r0, 7
    7a7a:	fd cf       	rjmp	.-6      	; 0x7a76 <FLASH_readByte+0x40>
  return SPDR;
    7a7c:	8e b5       	in	r24, 0x2e	; 46
  SPI_transfer(addr >> 16);
  SPI_transfer(addr >> 8);
  SPI_transfer(addr);
  //SPI.transfer(0); //"dont care", needed with SPIFLASH_ARRAYREAD command only
  uint8_t result = SPI_transfer(0);
  FLASH_UNSELECT;
    7a7e:	5d 9a       	sbi	0x0b, 5	; 11
  return result;
}
    7a80:	1f 91       	pop	r17
    7a82:	0f 91       	pop	r16
    7a84:	ff 90       	pop	r15
    7a86:	ef 90       	pop	r14
    7a88:	08 95       	ret

00007a8a <putch>:
    }
    putch(STK_OK);
  }
}

void putch(char ch) {
    7a8a:	98 2f       	mov	r25, r24
#ifndef SOFT_UART
  while (!(UART_SRA & _BV(UDRE0)));
    7a8c:	80 91 c0 00 	lds	r24, 0x00C0
    7a90:	85 ff       	sbrs	r24, 5
    7a92:	fc cf       	rjmp	.-8      	; 0x7a8c <putch+0x2>
  UART_UDR = ch;
    7a94:	90 93 c6 00 	sts	0x00C6, r25
      [uartBit] "I" (UART_TX_BIT)
    :
      "r25"
  );
#endif
}
    7a98:	08 95       	ret

00007a9a <getch>:
      [uartBit] "I" (UART_RX_BIT)
    :
      "r25"
);
#else
  while(!(UART_SRA & _BV(RXC0)))
    7a9a:	80 91 c0 00 	lds	r24, 0x00C0
    7a9e:	87 ff       	sbrs	r24, 7
    7aa0:	fc cf       	rjmp	.-8      	; 0x7a9a <getch>
    ;
  if (!(UART_SRA & _BV(FE0))) {
    7aa2:	80 91 c0 00 	lds	r24, 0x00C0
    7aa6:	84 fd       	sbrc	r24, 4
    7aa8:	01 c0       	rjmp	.+2      	; 0x7aac <getch+0x12>
}
#endif

// Watchdog functions. These are only safe with interrupts turned off.
void watchdogReset() {
  __asm__ __volatile__ (
    7aaa:	a8 95       	wdr
       * don't care that an invalid char is returned...)
       */
    watchdogReset();
  }
  
  ch = UART_UDR;
    7aac:	80 91 c6 00 	lds	r24, 0x00C6
  LED_PIN |= _BV(LED);
#endif
#endif

  return ch;
}
    7ab0:	08 95       	ret

00007ab2 <watchdogConfig>:
    "wdr\n"
  );
}

void watchdogConfig(uint8_t x) {
  WDTCSR = _BV(WDCE) | _BV(WDE);
    7ab2:	e0 e6       	ldi	r30, 0x60	; 96
    7ab4:	f0 e0       	ldi	r31, 0x00	; 0
    7ab6:	98 e1       	ldi	r25, 0x18	; 24
    7ab8:	90 83       	st	Z, r25
  WDTCSR = x;
    7aba:	80 83       	st	Z, r24
}
    7abc:	08 95       	ret

00007abe <verifySpace>:
  do getch(); while (--count);
  verifySpace();
}

void verifySpace() {
  if (getch() != CRC_EOP) {
    7abe:	ed df       	rcall	.-38     	; 0x7a9a <getch>
    7ac0:	80 32       	cpi	r24, 0x20	; 32
    7ac2:	19 f0       	breq	.+6      	; 0x7aca <verifySpace+0xc>
    watchdogConfig(WATCHDOG_16MS);    // shorten WD timeout
    7ac4:	88 e0       	ldi	r24, 0x08	; 8
    7ac6:	f5 df       	rcall	.-22     	; 0x7ab2 <watchdogConfig>
    7ac8:	ff cf       	rjmp	.-2      	; 0x7ac8 <verifySpace+0xa>
    while (1)			      // and busy-loop so that WD causes
      ;				      //  a reset and app start.
  }
  putch(STK_INSYNC);
    7aca:	84 e1       	ldi	r24, 0x14	; 20
}
    7acc:	de cf       	rjmp	.-68     	; 0x7a8a <putch>

00007ace <getNch>:
    ::[count] "M" (UART_B_VALUE)
  );
}
#endif

void getNch(uint8_t count) {
    7ace:	1f 93       	push	r17
    7ad0:	18 2f       	mov	r17, r24
  do getch(); while (--count);
    7ad2:	e3 df       	rcall	.-58     	; 0x7a9a <getch>
    7ad4:	11 50       	subi	r17, 0x01	; 1
    7ad6:	e9 f7       	brne	.-6      	; 0x7ad2 <getNch+0x4>
  verifySpace();
    7ad8:	f2 df       	rcall	.-28     	; 0x7abe <verifySpace>
}
    7ada:	1f 91       	pop	r17
    7adc:	08 95       	ret

00007ade <CheckFlashImage>:
  uint8_t result = SPI_transfer(0);
  FLASH_UNSELECT;
  return result;
}

void CheckFlashImage() {
    7ade:	9f 92       	push	r9
    7ae0:	af 92       	push	r10
    7ae2:	bf 92       	push	r11
    7ae4:	cf 92       	push	r12
    7ae6:	df 92       	push	r13
    7ae8:	ef 92       	push	r14
    7aea:	ff 92       	push	r15
    7aec:	0f 93       	push	r16
    7aee:	1f 93       	push	r17
    7af0:	cf 93       	push	r28
    7af2:	df 93       	push	r29
#ifdef DEBUG_ON
  putch('F');
    7af4:	86 e4       	ldi	r24, 0x46	; 70
    7af6:	c9 df       	rcall	.-110    	; 0x7a8a <putch>
#endif
  watchdogConfig(WATCHDOG_OFF);
    7af8:	80 e0       	ldi	r24, 0x00	; 0
    7afa:	db df       	rcall	.-74     	; 0x7ab2 <watchdogConfig>
  
#ifdef ANARDUINO
#if defined(__AVR_ATmega168__) || defined(__AVR_ATmega328P__) || defined(__AVR_ATmega88) || defined(__AVR_ATmega8__) || defined(__AVR_ATmega88__)
  DDRB |= _BV(SS) | _BV(PINB3) | _BV(PINB5); //OUTPUTS for SS, MOSI, SCK
    7afc:	84 b1       	in	r24, 0x04	; 4
    7afe:	8c 62       	ori	r24, 0x2C	; 44
    7b00:	84 b9       	out	0x04, r24	; 4
  DDRD |= _BV(FLASHSS); //OUTPUTS for FLASH_SS
    7b02:	55 9a       	sbi	0x0a, 5	; 10
  FLASH_UNSELECT; //unselect FLASH chip
    7b04:	5d 9a       	sbi	0x0b, 5	; 11
  PORTB |= _BV(SS); //set SS HIGH
    7b06:	2a 9a       	sbi	0x05, 2	; 5
  //SPCR = (SPCR & ~SPI_MODE_MASK) | SPI_MODE0 ; //SPI MODE 0
  //SPCR = (SPCR & ~SPI_CLOCK_MASK) | (SPI_CLOCK_DIV2 & SPI_CLOCK_MASK); //clock divider = 2
  //SPSR = (SPSR & ~SPI_2XCLOCK_MASK) | ((SPI_CLOCK_DIV2 >> 2) & SPI_2XCLOCK_MASK);

  // Warning: if the SS pin ever becomes a LOW INPUT then SPI automatically switches to Slave, so the data direction of the SS pin MUST be kept as OUTPUT.
  SPCR |= _BV(MSTR) | _BV(SPE); //enable SPI and set SPI to MASTER mode
    7b08:	8c b5       	in	r24, 0x2c	; 44
    7b0a:	80 65       	ori	r24, 0x50	; 80
    7b0c:	8c bd       	out	0x2c, r24	; 44

  //read first byte of JEDECID, if chip is present it should return a non-0 and non-FF value
  FLASH_SELECT;
    7b0e:	5d 98       	cbi	0x0b, 5	; 11

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7b10:	8f e9       	ldi	r24, 0x9F	; 159
    7b12:	8e bd       	out	0x2e, r24	; 46
  while (!(SPSR & _BV(SPIF)));
    7b14:	0d b4       	in	r0, 0x2d	; 45
    7b16:	07 fe       	sbrs	r0, 7
    7b18:	fd cf       	rjmp	.-6      	; 0x7b14 <CheckFlashImage+0x36>
  return SPDR;
    7b1a:	8e b5       	in	r24, 0x2e	; 46

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7b1c:	1e bc       	out	0x2e, r1	; 46
  while (!(SPSR & _BV(SPIF)));
    7b1e:	0d b4       	in	r0, 0x2d	; 45
    7b20:	07 fe       	sbrs	r0, 7
    7b22:	fd cf       	rjmp	.-6      	; 0x7b1e <CheckFlashImage+0x40>
  return SPDR;
    7b24:	8e b5       	in	r24, 0x2e	; 46

  //read first byte of JEDECID, if chip is present it should return a non-0 and non-FF value
  FLASH_SELECT;
  SPI_transfer(SPIFLASH_JEDECID);
  uint8_t deviceId = SPI_transfer(0);
  FLASH_UNSELECT;
    7b26:	5d 9a       	sbi	0x0b, 5	; 11

  // Disabled check, as it only returns 0xFF or 0x00 for some reasons
//  if (deviceId2==0 || deviceId2==0xFF) return;
  
  //global unprotect  
  FLASH_command(SPIFLASH_STATUSWRITE, 1);
    7b28:	81 e0       	ldi	r24, 0x01	; 1
    7b2a:	61 e0       	ldi	r22, 0x01	; 1
    7b2c:	65 df       	rcall	.-310    	; 0x79f8 <FLASH_command>

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7b2e:	1e bc       	out	0x2e, r1	; 46
  while (!(SPSR & _BV(SPIF)));
    7b30:	0d b4       	in	r0, 0x2d	; 45
    7b32:	07 fe       	sbrs	r0, 7
    7b34:	fd cf       	rjmp	.-6      	; 0x7b30 <CheckFlashImage+0x52>
  return SPDR;
    7b36:	8e b5       	in	r24, 0x2e	; 46
//  if (deviceId2==0 || deviceId2==0xFF) return;
  
  //global unprotect  
  FLASH_command(SPIFLASH_STATUSWRITE, 1);
  SPI_transfer(0);
  FLASH_UNSELECT;
    7b38:	5d 9a       	sbi	0x0b, 5	; 11
  
  //check if any flash image exists on external FLASH chip
  if (FLASH_readByte(0)=='F' && FLASH_readByte(1)=='L' && FLASH_readByte(2)=='X' && FLASH_readByte(6)==':' && FLASH_readByte(9)==':')
    7b3a:	60 e0       	ldi	r22, 0x00	; 0
    7b3c:	70 e0       	ldi	r23, 0x00	; 0
    7b3e:	80 e0       	ldi	r24, 0x00	; 0
    7b40:	90 e0       	ldi	r25, 0x00	; 0
    7b42:	79 df       	rcall	.-270    	; 0x7a36 <FLASH_readByte>
    7b44:	86 34       	cpi	r24, 0x46	; 70
    7b46:	09 f0       	breq	.+2      	; 0x7b4a <CheckFlashImage+0x6c>
    7b48:	c4 c0       	rjmp	.+392    	; 0x7cd2 <CheckFlashImage+0x1f4>
    7b4a:	61 e0       	ldi	r22, 0x01	; 1
    7b4c:	70 e0       	ldi	r23, 0x00	; 0
    7b4e:	80 e0       	ldi	r24, 0x00	; 0
    7b50:	90 e0       	ldi	r25, 0x00	; 0
    7b52:	71 df       	rcall	.-286    	; 0x7a36 <FLASH_readByte>
    7b54:	8c 34       	cpi	r24, 0x4C	; 76
    7b56:	09 f0       	breq	.+2      	; 0x7b5a <CheckFlashImage+0x7c>
    7b58:	bc c0       	rjmp	.+376    	; 0x7cd2 <CheckFlashImage+0x1f4>
    7b5a:	62 e0       	ldi	r22, 0x02	; 2
    7b5c:	70 e0       	ldi	r23, 0x00	; 0
    7b5e:	80 e0       	ldi	r24, 0x00	; 0
    7b60:	90 e0       	ldi	r25, 0x00	; 0
    7b62:	69 df       	rcall	.-302    	; 0x7a36 <FLASH_readByte>
    7b64:	88 35       	cpi	r24, 0x58	; 88
    7b66:	09 f0       	breq	.+2      	; 0x7b6a <CheckFlashImage+0x8c>
    7b68:	b4 c0       	rjmp	.+360    	; 0x7cd2 <CheckFlashImage+0x1f4>
    7b6a:	66 e0       	ldi	r22, 0x06	; 6
    7b6c:	70 e0       	ldi	r23, 0x00	; 0
    7b6e:	80 e0       	ldi	r24, 0x00	; 0
    7b70:	90 e0       	ldi	r25, 0x00	; 0
    7b72:	61 df       	rcall	.-318    	; 0x7a36 <FLASH_readByte>
    7b74:	8a 33       	cpi	r24, 0x3A	; 58
    7b76:	09 f0       	breq	.+2      	; 0x7b7a <CheckFlashImage+0x9c>
    7b78:	ac c0       	rjmp	.+344    	; 0x7cd2 <CheckFlashImage+0x1f4>
    7b7a:	69 e0       	ldi	r22, 0x09	; 9
    7b7c:	70 e0       	ldi	r23, 0x00	; 0
    7b7e:	80 e0       	ldi	r24, 0x00	; 0
    7b80:	90 e0       	ldi	r25, 0x00	; 0
    7b82:	59 df       	rcall	.-334    	; 0x7a36 <FLASH_readByte>
    7b84:	8a 33       	cpi	r24, 0x3A	; 58
    7b86:	09 f0       	breq	.+2      	; 0x7b8a <CheckFlashImage+0xac>
    7b88:	a4 c0       	rjmp	.+328    	; 0x7cd2 <CheckFlashImage+0x1f4>
  {
#ifdef DEBUG_ON
    putch('L');
    7b8a:	8c e4       	ldi	r24, 0x4C	; 76
    7b8c:	7e df       	rcall	.-260    	; 0x7a8a <putch>
#endif
    
    uint16_t imagesize = (FLASH_readByte(7)<<8) | FLASH_readByte(8);
    7b8e:	67 e0       	ldi	r22, 0x07	; 7
    7b90:	70 e0       	ldi	r23, 0x00	; 0
    7b92:	80 e0       	ldi	r24, 0x00	; 0
    7b94:	90 e0       	ldi	r25, 0x00	; 0
    7b96:	4f df       	rcall	.-354    	; 0x7a36 <FLASH_readByte>
    7b98:	08 2f       	mov	r16, r24
    7b9a:	68 e0       	ldi	r22, 0x08	; 8
    7b9c:	70 e0       	ldi	r23, 0x00	; 0
    7b9e:	80 e0       	ldi	r24, 0x00	; 0
    7ba0:	90 e0       	ldi	r25, 0x00	; 0
    7ba2:	49 df       	rcall	.-366    	; 0x7a36 <FLASH_readByte>
    7ba4:	10 e0       	ldi	r17, 0x00	; 0
    7ba6:	f0 2e       	mov	r15, r16
    7ba8:	ee 24       	eor	r14, r14
    7baa:	90 e0       	ldi	r25, 0x00	; 0
    7bac:	e8 2a       	or	r14, r24
    7bae:	f9 2a       	or	r15, r25
    if (imagesize%2!=0) return; //basic check that we got even # of bytes
    7bb0:	e0 fc       	sbrc	r14, 0
    7bb2:	91 c0       	rjmp	.+290    	; 0x7cd6 <CheckFlashImage+0x1f8>
    
    uint16_t b, i, nextAddress=0;
    
    LED_PIN |= _BV(LED);
    7bb4:	19 9a       	sbi	0x03, 1	; 3
    7bb6:	c0 e0       	ldi	r28, 0x00	; 0
    7bb8:	d0 e0       	ldi	r29, 0x00	; 0
    7bba:	cc 24       	eor	r12, r12
    7bbc:	dd 24       	eor	r13, r13
#endif
      
      //read 2 bytes (16 bits) from flash image, transfer them to page buffer
      b = FLASH_readByte(i+10); // flash image starts at position 10 on the external flash memory: FLX:XX:FLASH_IMAGE_BYTES_HERE...... (XX = two size bytes)
      b |= FLASH_readByte(i+11) << 8; //bytes are stored big endian on external flash, need to flip the bytes to little endian for transfer to internal flash
      __boot_page_fill_short((uint16_t)(void*)i,b);
    7bbe:	99 24       	eor	r9, r9
    7bc0:	93 94       	inc	r9

      //when 1 page is full (or we're on the last page), write it to the internal flash memory
      if ((i+2)%SPM_PAGESIZE==0 || (i+2==imagesize))
      {
        __boot_page_erase_short((uint16_t)(void*)nextAddress); //(i+2-SPM_PAGESIZE)
    7bc2:	73 e0       	ldi	r23, 0x03	; 3
    7bc4:	a7 2e       	mov	r10, r23
        boot_spm_busy_wait();
        // Write from programming buffer
        __boot_page_write_short((uint16_t)(void*)nextAddress ); //(i+2-SPM_PAGESIZE)
    7bc6:	65 e0       	ldi	r22, 0x05	; 5
    7bc8:	b6 2e       	mov	r11, r22
    7bca:	32 c0       	rjmp	.+100    	; 0x7c30 <CheckFlashImage+0x152>
    
    LED_PIN |= _BV(LED);
    for (i=0; i<imagesize; i+=2)
    {
#ifdef DEBUG_ON
      putch('*');
    7bcc:	8a e2       	ldi	r24, 0x2A	; 42
    7bce:	5d df       	rcall	.-326    	; 0x7a8a <putch>
#endif
      
      //read 2 bytes (16 bits) from flash image, transfer them to page buffer
      b = FLASH_readByte(i+10); // flash image starts at position 10 on the external flash memory: FLX:XX:FLASH_IMAGE_BYTES_HERE...... (XX = two size bytes)
    7bd0:	2a 96       	adiw	r28, 0x0a	; 10
    7bd2:	be 01       	movw	r22, r28
    7bd4:	80 e0       	ldi	r24, 0x00	; 0
    7bd6:	90 e0       	ldi	r25, 0x00	; 0
    7bd8:	2e df       	rcall	.-420    	; 0x7a36 <FLASH_readByte>
    7bda:	08 2f       	mov	r16, r24
    7bdc:	10 e0       	ldi	r17, 0x00	; 0
      b |= FLASH_readByte(i+11) << 8; //bytes are stored big endian on external flash, need to flip the bytes to little endian for transfer to internal flash
    7bde:	21 96       	adiw	r28, 0x01	; 1
    7be0:	be 01       	movw	r22, r28
    7be2:	80 e0       	ldi	r24, 0x00	; 0
    7be4:	90 e0       	ldi	r25, 0x00	; 0
    7be6:	2b 97       	sbiw	r28, 0x0b	; 11
    7be8:	26 df       	rcall	.-436    	; 0x7a36 <FLASH_readByte>
      __boot_page_fill_short((uint16_t)(void*)i,b);
    7bea:	90 e0       	ldi	r25, 0x00	; 0
    7bec:	98 2f       	mov	r25, r24
    7bee:	88 27       	eor	r24, r24
    7bf0:	80 2b       	or	r24, r16
    7bf2:	91 2b       	or	r25, r17
    7bf4:	fe 01       	movw	r30, r28
    7bf6:	0c 01       	movw	r0, r24
    7bf8:	97 be       	out	0x37, r9	; 55
    7bfa:	e8 95       	spm
    7bfc:	11 24       	eor	r1, r1

      //when 1 page is full (or we're on the last page), write it to the internal flash memory
      if ((i+2)%SPM_PAGESIZE==0 || (i+2==imagesize))
    7bfe:	22 96       	adiw	r28, 0x02	; 2
    7c00:	ce 01       	movw	r24, r28
    7c02:	8f 77       	andi	r24, 0x7F	; 127
    7c04:	90 70       	andi	r25, 0x00	; 0
    7c06:	89 2b       	or	r24, r25
    7c08:	19 f0       	breq	.+6      	; 0x7c10 <CheckFlashImage+0x132>
    7c0a:	ce 15       	cp	r28, r14
    7c0c:	df 05       	cpc	r29, r15
    7c0e:	81 f4       	brne	.+32     	; 0x7c30 <CheckFlashImage+0x152>
      {
        __boot_page_erase_short((uint16_t)(void*)nextAddress); //(i+2-SPM_PAGESIZE)
    7c10:	f6 01       	movw	r30, r12
    7c12:	a7 be       	out	0x37, r10	; 55
    7c14:	e8 95       	spm
        boot_spm_busy_wait();
    7c16:	07 b6       	in	r0, 0x37	; 55
    7c18:	00 fc       	sbrc	r0, 0
    7c1a:	fd cf       	rjmp	.-6      	; 0x7c16 <CheckFlashImage+0x138>
        // Write from programming buffer
        __boot_page_write_short((uint16_t)(void*)nextAddress ); //(i+2-SPM_PAGESIZE)
    7c1c:	f6 01       	movw	r30, r12
    7c1e:	b7 be       	out	0x37, r11	; 55
    7c20:	e8 95       	spm
        boot_spm_busy_wait();
    7c22:	07 b6       	in	r0, 0x37	; 55
    7c24:	00 fc       	sbrc	r0, 0
    7c26:	fd cf       	rjmp	.-6      	; 0x7c22 <CheckFlashImage+0x144>
        nextAddress += SPM_PAGESIZE;
    7c28:	80 e8       	ldi	r24, 0x80	; 128
    7c2a:	90 e0       	ldi	r25, 0x00	; 0
    7c2c:	c8 0e       	add	r12, r24
    7c2e:	d9 1e       	adc	r13, r25
    if (imagesize%2!=0) return; //basic check that we got even # of bytes
    
    uint16_t b, i, nextAddress=0;
    
    LED_PIN |= _BV(LED);
    for (i=0; i<imagesize; i+=2)
    7c30:	ce 15       	cp	r28, r14
    7c32:	df 05       	cpc	r29, r15
    7c34:	08 f4       	brcc	.+2      	; 0x7c38 <CheckFlashImage+0x15a>
    7c36:	ca cf       	rjmp	.-108    	; 0x7bcc <CheckFlashImage+0xee>
        __boot_page_write_short((uint16_t)(void*)nextAddress ); //(i+2-SPM_PAGESIZE)
        boot_spm_busy_wait();
        nextAddress += SPM_PAGESIZE;
      }
    }
    LED_PIN &= ~_BV(LED);
    7c38:	19 98       	cbi	0x03, 1	; 3

#if defined(RWWSRE)
    // Reenable read access to flash
    boot_rww_enable();
    7c3a:	81 e1       	ldi	r24, 0x11	; 17
    7c3c:	87 bf       	out	0x37, r24	; 55
    7c3e:	e8 95       	spm
#endif

#ifdef DEBUG_ON
    putch('E');
    7c40:	85 e4       	ldi	r24, 0x45	; 69
    7c42:	23 df       	rcall	.-442    	; 0x7a8a <putch>
    7c44:	ee 24       	eor	r14, r14
    7c46:	ff 24       	eor	r15, r15
    7c48:	87 01       	movw	r16, r14

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7c4a:	45 e0       	ldi	r20, 0x05	; 5
    7c4c:	d4 2e       	mov	r13, r20
#ifdef ANARDUINO
	// Anarduino doesn't support 32K block erase. Do it, with 8 pages of 4k each
	int page;
	long address;
	for (page = 0, address=0; page< 8; page++) {
	  FLASH_command(SPIFLASH_BLOCKERASE_4K, 1);
    7c4e:	80 e2       	ldi	r24, 0x20	; 32
    7c50:	61 e0       	ldi	r22, 0x01	; 1
    7c52:	d2 de       	rcall	.-604    	; 0x79f8 <FLASH_command>
	  SPI_transfer(address >> 16);
    7c54:	c8 01       	movw	r24, r16
    7c56:	bb 27       	eor	r27, r27
    7c58:	97 fd       	sbrc	r25, 7
    7c5a:	b0 95       	com	r27
    7c5c:	ab 2f       	mov	r26, r27

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7c5e:	8e bd       	out	0x2e, r24	; 46
  while (!(SPSR & _BV(SPIF)));
    7c60:	0d b4       	in	r0, 0x2d	; 45
    7c62:	07 fe       	sbrs	r0, 7
    7c64:	fd cf       	rjmp	.-6      	; 0x7c60 <CheckFlashImage+0x182>
  return SPDR;
    7c66:	8e b5       	in	r24, 0x2e	; 46
	int page;
	long address;
	for (page = 0, address=0; page< 8; page++) {
	  FLASH_command(SPIFLASH_BLOCKERASE_4K, 1);
	  SPI_transfer(address >> 16);
	  SPI_transfer(address >> 8);
    7c68:	bb 27       	eor	r27, r27
    7c6a:	17 fd       	sbrc	r17, 7
    7c6c:	ba 95       	dec	r27
    7c6e:	a1 2f       	mov	r26, r17
    7c70:	90 2f       	mov	r25, r16
    7c72:	8f 2d       	mov	r24, r15

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7c74:	8e bd       	out	0x2e, r24	; 46
  while (!(SPSR & _BV(SPIF)));
    7c76:	0d b4       	in	r0, 0x2d	; 45
    7c78:	07 fe       	sbrs	r0, 7
    7c7a:	fd cf       	rjmp	.-6      	; 0x7c76 <CheckFlashImage+0x198>
  return SPDR;
    7c7c:	8e b5       	in	r24, 0x2e	; 46

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7c7e:	1e bc       	out	0x2e, r1	; 46
  while (!(SPSR & _BV(SPIF)));
    7c80:	0d b4       	in	r0, 0x2d	; 45
    7c82:	07 fe       	sbrs	r0, 7
    7c84:	fd cf       	rjmp	.-6      	; 0x7c80 <CheckFlashImage+0x1a2>
  return SPDR;
    7c86:	8e b5       	in	r24, 0x2e	; 46
	for (page = 0, address=0; page< 8; page++) {
	  FLASH_command(SPIFLASH_BLOCKERASE_4K, 1);
	  SPI_transfer(address >> 16);
	  SPI_transfer(address >> 8);
	  SPI_transfer(address);
	  FLASH_UNSELECT;
    7c88:	5d 9a       	sbi	0x0b, 5	; 11
  return SPDR;
}

uint8_t FLASH_busy()
{
  FLASH_SELECT;
    7c8a:	5d 98       	cbi	0x0b, 5	; 11

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7c8c:	de bc       	out	0x2e, r13	; 46
  while (!(SPSR & _BV(SPIF)));
    7c8e:	0d b4       	in	r0, 0x2d	; 45
    7c90:	07 fe       	sbrs	r0, 7
    7c92:	fd cf       	rjmp	.-6      	; 0x7c8e <CheckFlashImage+0x1b0>
  return SPDR;
    7c94:	8e b5       	in	r24, 0x2e	; 46

#define DEBUG_ON                            // uncomment to enable Serial debugging 
                                              // (will output different characters depending on which path the bootloader takes)

uint8_t SPI_transfer(uint8_t _data) {
  SPDR = _data;
    7c96:	1e bc       	out	0x2e, r1	; 46
  while (!(SPSR & _BV(SPIF)));
    7c98:	0d b4       	in	r0, 0x2d	; 45
    7c9a:	07 fe       	sbrs	r0, 7
    7c9c:	fd cf       	rjmp	.-6      	; 0x7c98 <CheckFlashImage+0x1ba>
  return SPDR;
    7c9e:	8e b5       	in	r24, 0x2e	; 46
uint8_t FLASH_busy()
{
  FLASH_SELECT;
  SPI_transfer(SPIFLASH_STATUSREAD);
  uint8_t status = SPI_transfer(0);
  FLASH_UNSELECT;
    7ca0:	5d 9a       	sbi	0x0b, 5	; 11
	  SPI_transfer(address >> 16);
	  SPI_transfer(address >> 8);
	  SPI_transfer(address);
	  FLASH_UNSELECT;
	  
	  while (FLASH_busy());
    7ca2:	80 fd       	sbrc	r24, 0
    7ca4:	f2 cf       	rjmp	.-28     	; 0x7c8a <CheckFlashImage+0x1ac>

#ifdef ANARDUINO
	// Anarduino doesn't support 32K block erase. Do it, with 8 pages of 4k each
	int page;
	long address;
	for (page = 0, address=0; page< 8; page++) {
    7ca6:	90 e0       	ldi	r25, 0x00	; 0
    7ca8:	e9 16       	cp	r14, r25
    7caa:	90 e7       	ldi	r25, 0x70	; 112
    7cac:	f9 06       	cpc	r15, r25
    7cae:	90 e0       	ldi	r25, 0x00	; 0
    7cb0:	09 07       	cpc	r16, r25
    7cb2:	90 e0       	ldi	r25, 0x00	; 0
    7cb4:	19 07       	cpc	r17, r25
    7cb6:	49 f0       	breq	.+18     	; 0x7cca <CheckFlashImage+0x1ec>
	  SPI_transfer(address);
	  FLASH_UNSELECT;
	  
	  while (FLASH_busy());

	  address += 0x1000;	  
    7cb8:	80 e0       	ldi	r24, 0x00	; 0
    7cba:	90 e1       	ldi	r25, 0x10	; 16
    7cbc:	a0 e0       	ldi	r26, 0x00	; 0
    7cbe:	b0 e0       	ldi	r27, 0x00	; 0
    7cc0:	e8 0e       	add	r14, r24
    7cc2:	f9 1e       	adc	r15, r25
    7cc4:	0a 1f       	adc	r16, r26
    7cc6:	1b 1f       	adc	r17, r27
    7cc8:	c2 cf       	rjmp	.-124    	; 0x7c4e <CheckFlashImage+0x170>
    else FLASH_command(SPIFLASH_BLOCKERASE_64K, 1);
    SPI_transfer(0);
    SPI_transfer(0);
    SPI_transfer(0);
#endif
    FLASH_UNSELECT;
    7cca:	5d 9a       	sbi	0x0b, 5	; 11

    //now trigger a watchdog reset
    watchdogConfig(WATCHDOG_16MS);  // short WDT timeout
    7ccc:	88 e0       	ldi	r24, 0x08	; 8
    7cce:	f1 de       	rcall	.-542    	; 0x7ab2 <watchdogConfig>
    7cd0:	ff cf       	rjmp	.-2      	; 0x7cd0 <CheckFlashImage+0x1f2>
    while (1); 		                  // and busy-loop so that WD causes a reset and app start
  }
#ifdef DEBUG_ON
  putch('X');
    7cd2:	88 e5       	ldi	r24, 0x58	; 88
    7cd4:	da de       	rcall	.-588    	; 0x7a8a <putch>
#endif
}
    7cd6:	df 91       	pop	r29
    7cd8:	cf 91       	pop	r28
    7cda:	1f 91       	pop	r17
    7cdc:	0f 91       	pop	r16
    7cde:	ff 90       	pop	r15
    7ce0:	ef 90       	pop	r14
    7ce2:	df 90       	pop	r13
    7ce4:	cf 90       	pop	r12
    7ce6:	bf 90       	pop	r11
    7ce8:	af 90       	pop	r10
    7cea:	9f 90       	pop	r9
    7cec:	08 95       	ret

00007cee <appStart>:

void appStart(uint8_t rstFlags) {
  // save the reset flags in the designated register
  //  This can be saved in a main program by putting code in .init0 (which
  //  executes before normal c init code) to save R2 to a global variable.
  __asm__ __volatile__ ("mov r2, %0\n" :: "r" (rstFlags));
    7cee:	28 2e       	mov	r2, r24

  watchdogConfig(WATCHDOG_OFF);
    7cf0:	80 e0       	ldi	r24, 0x00	; 0
    7cf2:	df de       	rcall	.-578    	; 0x7ab2 <watchdogConfig>
  __asm__ __volatile__ (
    7cf4:	ee 27       	eor	r30, r30
    7cf6:	ff 27       	eor	r31, r31
    7cf8:	09 94       	ijmp
